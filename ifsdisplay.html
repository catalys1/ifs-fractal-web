<html>
<head>
    <link rel='stylesheet' href='stylesheet.css'>
</head>
<body onload="startup();">
<div class='col'>
    <div class='row align-end'>
        <!-- <button onclick="renderFractal(system);">Render</button> -->
        <span style="padding-left:10px;">
            <label for='iters'>Iterations</label>
            <input id='iters' type='number' value=100000 min=0 max=500000 step=1000></input>
        </span>
    </div>
    <div class='row'>
        <div>
            <canvas id="ifs-canvas" height='400' width='400'> </canvas>
        </div>
        <div>
            <canvas id='decomp-canvas' width=400 height=400></canvas>
        </div>
    </div>
    <div class='row'>
        <div>
            <canvas id='tform-canvas' width=400 height=400></canvas>
        </div>
        <div class='col'>
            <div class='header'>System parameters</div>
            <div class='row'>
                <input id='system-size' type='number' min=2 max=16 value=2></input>
                <label for='system-size' style="padding-left:10px;">Number of transforms</label>
            </div>
            <div class='row'>
                <input id='step-size' type='number' min='0.01' max='0.5' value='0.1' step='0.01'>
                </input>
                <label for='step-size' style="padding-left:10px;">Step size</label>
            </div>
            <div id='params' class='col'></div>
            <button onclick="sampleRandomSystem()">Random</button>
        </div>
    </div>
</div>
</body>

<script src=ifs.js></script>
<script src=manipulate.js></script>
<script>

// Global state
var system = null;
var manipulator;
// -------------------------------------------------------

function sampleRandomSystem() {
    var n = parseInt(document.getElementById('system-size').value);
    system = randomSystem(n);
    displayParams();
    renderFractal(system);
}

function renderFractal(sys) {
    var iters = document.getElementById('iters').value;
    var points = iterateIFS(sys, iters);
    drawPoints(points);
    manipulator.showSystemDecomp(sys);
}

function matrixCard(mat) {
    var card = document.createElement('div');
    card.classList.add('col')
    for (let i = 0; i < mat.length; i++) {
        var row = document.createElement('span');
        for (let j = 0; j < mat[i].length; j++) {
            var cell = document.createElement('input');
            cell.type = 'number';
            cell.step = document.getElementById('step-size').value;
            cell.value = mat[i][j].toPrecision(4);
            let notlast = j < mat[i].length - 1;
            cell.min = notlast ? '-1' : '-10';
            cell.max = notlast ? '1' : '10'
            cell.oninput = function(ev) {
                let sys = readTextParams();
                renderFractal(sys);
            }
            row.appendChild(cell);
        }
        card.appendChild(row);
    }
    return card;
}

function readTextParams() {
    var container = document.getElementById('params');
    var sys = [];
    for (let i = 0; i < container.children.length; i++) {
        var mat = [];
        var mat_els = container.children[i];
        for (let j = 0; j < mat_els.children.length; j++) {
            var row = [];
            let row_els = mat_els.children[j];
            for (let k = 0; k < row_els.children.length; k++) {
                let v = parseFloat(row_els.children[k].value);
                row.push(v);
            }
            mat.push(row);
        }
        sys.push(mat);
    }
    return sys;
}

function displayParams() {
    var container = document.getElementById('params');
    while (params.firstChild) {
        container.removeChild(container.lastChild);
    }
    for (let i = 0; i < system.length; i++) {
        let card = matrixCard(system[i]);
        container.appendChild(card);
    }
}

function drawPoints(points, region=null) {
    var can = document.getElementById('ifs-canvas');
    var ctx = can.getContext('2d');

    if (region === null)
        region = minmax(points);

    var w = can.width;
    var h = can.height;
    var ar = [];
    for (let i = 0; i < h; i++) {
        let r = [];
        for (let j = 0; j < w; j++) {
            r.push(0);
        }
        ar.push(r);
    }
    for (let i = 0; i < points.length; i++) {
        let x = Math.floor((points[i][0] - region[0]) / (region[2]-region[0]) * (w-1));
        let y = Math.floor((points[i][1] - region[1]) / (region[3]-region[1]) * (h-1));
        if (x >= 0 && x < w && y >= 0 && y < h) {
            ar[y][x] = 1;
        }
    }

    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = 'black';
    for (let i = 0; i < h; i++) {
        for (let j = 0; j < w; j++) {
            if (ar[i][j] == 1) {
                ctx.fillRect(i, j, 1, 1);
            }
        }
    }
}

// function worldToScreen(x, y, w, h) {
//     var cx = w / 2;
//     var cy = h / 2;
//     var xw = (x + pView.cx) * w / 2 / pView.z + cx;
//     var yw = -(y + pView.cy) * h / 2 / pView.z + cy;
//     return [xw, yw];
// }

// function drawVec(x1, y1, x2, y2, ctx, color=null) {
//     color = color === null ? 'black' : color;
//     ctx.strokeStyle = color;
//     ctx.beginPath();
//     ctx.moveTo(x1, y1);
//     ctx.lineTo(x2, y2);
//     ctx.stroke();

//     ctx.beginPath();
//     ctx.arc(x2, y2, 5, 0, Math.PI * 2);
//     ctx.stroke();
// }

// function drawOrigin(x, y, ctx, color=null) {
//     color = color === null ? 'black' : color;
//     ctx.strokeStyle = color;
//     ctx.beginPath();
//     ctx.arc(x, y, 7, 0, Math.PI * 2)
//     ctx.stroke();
// }

// function drawCoordinates(w, h, ctx) {
//     ctx.fillStyle = '#F5F5F5';
//     ctx.strokeStyle = 'white';
//     var fsize = 10;
//     ctx.font = fsize.toString() + 'px Courier';

//     ctx.fillRect(0, 0, w, h);
//     ctx.fillStyle = 'black';

//     var ng = 8;
//     for (let i = 1; i < ng; i++) {
//         let u = w * i / ng;
//         let v = h * i / ng;

//         // horizontal
//         ctx.beginPath();
//         ctx.moveTo(0, v);
//         ctx.lineTo(w, v);
//         ctx.stroke();
//         let loc = pView.cy + (i - ng / 2) * 2 * pView.z / ng;
//         let loc_s = (loc > 0 ? '+' : loc == 0 ? ' ' : '') + loc.toFixed(2);
//         ctx.fillText(loc_s, 2, v + 0.25*fsize);

//         // vertical
//         ctx.beginPath();
//         ctx.moveTo(u, 0);
//         ctx.lineTo(u, h);
//         ctx.stroke();
//         loc = pView.cx + (i - ng / 2) * 2 * pView.z / ng;
//         loc_s = (loc > 0 ? '+' : loc == 0 ? ' ' : '') + loc.toFixed(2);
//         ctx.fillText(loc_s, u - 2*fsize, 2+fsize*(1 + (i+1) % 2));
//     }
// }

// function showSystemDecomp(sys) {
//     var can = document.getElementById('decomp-canvas');
//     ctx = can.getContext('2d');

//     var can_w = can.width;
//     var can_h = can.height;

//     drawCoordinates(can_w, can_h, ctx);

//     ctx.moveTo(can_w, 0);
//     ctx.lineTo(can_w, can_h);
//     ctx.stroke();

//     for (let i = 0; i < sys.length; i++) {
//         var w = can_w;
//         var h = can_h;

//         var svd = svd2x2(sys[i]);
//         var s1 = svd.S[0];
//         var s2 = svd.S[1];
//         var bx = sys[i][0][2];
//         var by = sys[i][1][2];
//         var bw = worldToScreen(bx, by, w, h);

//         // draw
//         if (bw[0] >= 0 && bw[0] < w && bw[1] >= 0 && bw[1] < h) {
//             // left singular vectors (U)
//             xy = worldToScreen(bx + svd.U[0][0] * s1, by + svd.U[1][0] * s2, w, h);
//             drawVec(bw[0], bw[1], xy[0], xy[1], ctx, 'red');
//             xy = worldToScreen(bx + svd.U[0][1] * s1, by + svd.U[1][1] * s2, w, h);
//             drawVec(bw[0], bw[1], xy[0], xy[1], ctx, 'red');
//             // right singular vectors (V^T)
//             xy = worldToScreen(bx + svd.V[0][0], by + svd.V[1][0], w, h);
//             drawVec(bw[0], bw[1], xy[0], xy[1], ctx, 'blue');
//             xy = worldToScreen(bx + svd.V[0][1], by + svd.V[1][1], w, h);
//             drawVec(bw[0], bw[1], xy[0], xy[1], ctx, 'blue');
//             drawOrigin(bw[0], bw[1], ctx);
//         }
            
//     }
// }

function startup() {
    manipulator = new ManipulateDisplay(document.getElementById('decomp-canvas'));
    system = [
        [[0.5, -0.5, 0],
         [0.5, 0.5,  0]],
        [[-0.5, -0.5, 1],
         [0.5, -0.5,  0]]
    ];
    displayParams();

    var stepper = document.getElementById('step-size');
    stepper.oninput = function(ev) {
        var new_step = stepper.value;
        var container = document.getElementById('params');
        for (let i = 0; i < container.children.length; i++) {
            var mat_els = container.children[i];
            for (let j = 0; j < mat_els.children.length; j++) {
                let row_els = mat_els.children[j];
                for (let k = 0; k < row_els.children.length; k++) {
                    row_els.children[k].step = new_step;
                }
            }
        }

    }

    renderFractal(system);
}

</script>

</html>